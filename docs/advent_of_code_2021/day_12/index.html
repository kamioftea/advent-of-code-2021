<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="This is my solution for Advent of Code - Day 12 - Passage Pathing"><meta name="keywords" content="rust, rustlang, rust-lang, day_12"><title>advent_of_code_2021::day_12 - Rust</title><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../../ayu.css" disabled ><script id="default-settings" ></script><script src="../../storage.js"></script><script src="../../crates.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../favicon.svg"><style type="text/css">#crate-search{background-image:url("../../down-arrow.svg");}</style></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a href='../../advent_of_code_2021/index.html'><div class='logo-container rust-logo'><img src='../../rust-logo.png' alt='logo'></div></a><h2 class="location">Module day_12</h2><div class="sidebar-elems"><div class="block items"><ul><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#functions">Functions</a></li></ul></div><div id="sidebar-vars" data-name="day_12" data-ty="mod" data-relpath="./"></div><script defer src="./sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="18" height="18" alt="Pick another theme!" src="../../brush.svg"></button><div id="theme-choices" role="menu"></div></div><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press â€˜Sâ€™ to search, â€˜?â€™ for more optionsâ€¦" type="search"></div><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../../settings.html" title="settings"><img width="18" height="18" alt="Change settings" src="../../wheel.svg"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="in-band">Module <a href="../index.html">advent_of_code_2021</a>::<wbr><a class="mod" href="#">day_12</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../../src/advent_of_code_2021/day_12.rs.html#1-305" title="goto source code">[src]</a></span></h1><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>This is my solution for <a href="https://adventofcode.com/2021/day/12">Advent of Code - Day 12 - <em>Passage Pathing</em></a></p>
<p>Today was graph traversing. The puzzle was to find all the paths to traverse a set of caves, some of which could
be visited any number of times (large), and only once-ish (small). I say ish, because part twoâ€™s extension was
that exactly one (1) small cave could be revisited in the path. Iâ€™ve previously struggled with graph
representation in Rust, and today was tricky, but I was able to apply the learnings from previous years and get the
borrow checker happy pretty quickly. This was a more impressive feat with my original solution that used the
string representation and a hash map rather than a vector and mapping the labels to indices.</p>
<p>There are two main  structs used in todayâ€™s solutions. <a href="struct.Cave.html" title="Cave"><code>Cave</code></a> represents a node in the graph, tracking if it is
large or small (or one of the special types start and end), and the other cave(s) linked to that cave.
<a href="fn.parse_input.html" title="parse_input"><code>parse_input</code></a> takes the puzzle input and converts it into a <code>Vec&lt;Cave&gt;</code>, using <a href="fn.get_index.html" title="get_index"><code>get_index</code></a> to manage the
mapping of label -&gt; index. <a href="struct.Path.html" title="Path"><code>Path</code></a> tracks an in progress path using a set of the visited nodes (using a usize
as a bitmap), the current position of the head of the path, and (for part two) a flag tracking whether it has used
its one-off repeat visit.</p>
<p><a href="fn.build_paths.html" title="build_paths"><code>build_paths</code></a> and <a href="struct.Path.html#method.with_cave" title="Path::with_cave"><code>Path::with_cave</code></a> handle the logic for solving both parts. <a href="fn.build_paths.html" title="build_paths"><code>build_paths</code></a> taking a flag to
control which part it is solving. The strategy is to have a stack of paths to analyse, pop one at a time, append
each linked cave to that path in turn using <a href="struct.Path.html#method.with_cave" title="Path::with_cave"><code>Path::with_cave</code></a>, and push the valid paths into the completed list
if weâ€™ve appended â€˜endâ€™, otherwise back onto the stack of pending paths - so doing depth first search. Using a
queue would give breadth first search, but itâ€™s a moot point as we need the exhaustive list of paths anyway.</p>
<p>Today was the worst in terms of initial performance. It was taking ~400ms to run both parts, compared to ~100ms
to run all of days 1 to 11. My initial implementation was using a <code>HashSet&lt;&amp;str&gt;</code> for the visited nodes, and a
<code>HashMap&lt;&amp;str, Cave&gt;</code> for the cave list. Switching this over to a <code>usize</code> bitmap, and <code>Vec&lt;Cave&gt;</code> brought it down
to ~130ms, better but still slower than the other days combined. The second optimisation was that I had
previously been tracking the full path up to that point as a <code>Vec&lt;usize&gt;</code> (originally <code>Vec&lt;&amp;str&gt;</code>.) Because the
paths branch, adding a new cave to a path needs to copy it, so the original is left as is to have the next linked
cave appended. This had been useful for debugging, esp. when it was using <code>&amp;str</code>s to track the caves, but wasnâ€™t
actually needed to calculate the solution - the visited set and current position are sufficient. Removing this
<code>Vec</code> and associated copying brought it down to ~10ms ðŸŽ‰. I was very glad for the unit tests that let me refactor
each step with confidence. Getting <a href="struct.Path.html#method.with_cave" title="Path::with_cave"><code>Path::with_cave</code></a> right took a few attempts, and the tests quickly helped me
identify where Iâ€™d gone wrong.</p>
</div></details><h2 id="structs" class="section-header"><a href="#structs">Structs</a></h2>
<div class="item-table"><div class="item-left module-item"><a class="struct" href="struct.Cave.html" title="advent_of_code_2021::day_12::Cave struct">Cave</a></div><div class="item-right docblock-short"></div><div class="item-left module-item"><a class="struct" href="struct.Path.html" title="advent_of_code_2021::day_12::Path struct">Path</a></div><div class="item-right docblock-short"></div></div><h2 id="enums" class="section-header"><a href="#enums">Enums</a></h2>
<div class="item-table"><div class="item-left module-item"><a class="enum" href="enum.CaveType.html" title="advent_of_code_2021::day_12::CaveType enum">CaveType</a></div><div class="item-right docblock-short"><p>Track the four possible node types that dictate how they can be visited</p>
</div></div><h2 id="functions" class="section-header"><a href="#functions">Functions</a></h2>
<div class="item-table"><div class="item-left module-item"><a class="fn" href="fn.build_paths.html" title="advent_of_code_2021::day_12::build_paths fn">build_paths</a></div><div class="item-right docblock-short"><p>Find the start and end indices, initialise a single path at the start position, and an empty list of complete
paths. Take nodes from the stack, iterating through the linked caves and pushing all valid new paths back onto the
stack (if incomplete) or into the list of complete paths if their updated position is the end node, repeat until
the stack is exhausted and return the completed path.</p>
</div><div class="item-left module-item"><a class="fn" href="fn.get_index.html" title="advent_of_code_2021::day_12::get_index fn">get_index</a></div><div class="item-right docblock-short"><p>Helper for parse_input that handles mapping a label to an index in the cave vector, initialising a cave and dding it
to the vector and lookup table if itâ€™s a new cave.</p>
</div><div class="item-left module-item"><a class="fn" href="fn.parse_input.html" title="advent_of_code_2021::day_12::parse_input fn">parse_input</a></div><div class="item-right docblock-short"><p>Split each line into the two ends of the edge, lookup/create the cave for each, and add each to the opposite
endâ€™s list of links.</p>
</div><div class="item-left module-item"><a class="fn" href="fn.run.html" title="advent_of_code_2021::day_12::run fn">run</a></div><div class="item-right docblock-short"><p>The entry point for running the solutions with the â€˜realâ€™ puzzle input.</p>
</div></div></section><section id="search" class="content hidden"></section><div id="rustdoc-vars" data-root-path="../../" data-current-crate="advent_of_code_2021" data-search-index-js="../../search-index.js" data-search-js="../../search.js"></div>
    <script src="../../main.js"></script>
</body></html>