<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="This is my solution for Advent of Code - Day 14 - Extended Polymerization"><meta name="keywords" content="rust, rustlang, rust-lang, day_14"><title>advent_of_code_2021::day_14 - Rust</title><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../../ayu.css" disabled ><script id="default-settings" ></script><script src="../../storage.js"></script><script src="../../crates.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../favicon.svg"><style type="text/css">#crate-search{background-image:url("../../down-arrow.svg");}</style></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a href='../../advent_of_code_2021/index.html'><div class='logo-container rust-logo'><img src='../../rust-logo.png' alt='logo'></div></a><h2 class="location">Module day_14</h2><div class="sidebar-elems"><div class="block items"><ul><li><a href="#functions">Functions</a></li><li><a href="#types">Type Definitions</a></li></ul></div><div id="sidebar-vars" data-name="day_14" data-ty="mod" data-relpath="./"></div><script defer src="./sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="18" height="18" alt="Pick another theme!" src="../../brush.svg"></button><div id="theme-choices" role="menu"></div></div><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../../settings.html" title="settings"><img width="18" height="18" alt="Change settings" src="../../wheel.svg"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="in-band">Module <a href="../index.html">advent_of_code_2021</a>::<wbr><a class="mod" href="#">day_14</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../../src/advent_of_code_2021/day_14.rs.html#1-300" title="goto source code">[src]</a></span></h1><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>This is my solution for <a href="https://adventofcode.com/2021/day/14">Advent of Code - Day 14 - <em>Extended Polymerization</em></a></p>
<p>By the end of today I was thinking it was a lot like <a href="../day_6/index.html" title="crate::day_6"><code>crate::day_6</code></a>, but I missed how
exponential it was when first reading, so implemented the naive versions for part one, but that
did not complete before it ran out of memory for part two. I ended up noting that each pair
would become two new pairs each step (or stay as the same pair if there was no insertion mapping
for that pair). This meant I could just track the counts of each pair in a given iteration, and
work out the next step by walking through the current pair counts and adding its count to each
of the pairs it maps to in the counts map for the next iteration.</p>
<p>The types are pretty convoluted today, enough so that I aliased the Polymer as map of pairs -&gt;
counts, and pair mapping of pair -&gt; pairs when iterated into <a href="type.Polymer.html" title="Polymer"><code>Polymer</code></a> and <a href="type.PairMap.html" title="PairMap"><code>PairMap</code></a>
respectively. That said, whilst the types were complex, they were a great guide for what
transformations I needed to do at each step, and once I’d satisfied the type checker the
solutions just worked.</p>
<p>There’s quite a lot of moving parts today, mostly involved in building the internal
representation from the input, and converting the result into the required output.
<a href="fn.parse_input.html" title="parse_input"><code>parse_input</code></a> takes the file, transforms the seed polymer into the required map of pair counts
using <a href="fn.into_pair_counts.html" title="into_pair_counts"><code>into_pair_counts</code></a>, and then takes the remaining lines and creates the PairMap. i.e. a
mapping of <code>AB -&gt; C</code> becomes <code>('A', 'B') =&gt; [('A', 'C'), ('C', 'B')]</code> which means when there is
a pair <code>AB</code> the next iteration will instead have two pairs, <code>AC</code> and <code>CB</code>. <a href="fn.intersperse.html" title="intersperse"><code>intersperse</code></a>
handles performing a single insertion cycle, and <a href="fn.iterate.html" title="iterate"><code>iterate</code></a> recursively calls <a href="fn.intersperse.html" title="intersperse"><code>intersperse</code></a>
for the required number of cycles. Finally <a href="fn.summarise.html" title="summarise"><code>summarise</code></a> works out the counts of each of the
characters. With the current implementation we need to take the counts of both parts of each
pair to account for the first and last characters. This in itself involves some complex type
munging, so has been extracted to <a href="fn.into_count_by.html" title="into_count_by"><code>into_count_by</code></a>. If I was building this again I’d consider
making a struct to hold the polymer, including caching the final character from the seed. This
would allow just counting the first character in each pair and adding 1 to the count that
matches the final character. As it is, this works and is quick enough that it’s not worth the
effort.</p>
</div></details><h2 id="functions" class="section-header"><a href="#functions">Functions</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.intersperse.html" title="advent_of_code_2021::day_14::intersperse fn">intersperse</a></div><div class="item-right docblock-short"><p>The name is a legacy from the naive solution where this was mapping each pair to the new pairs
and building the full polymer in order which failed as the final polymer had ~21 trillion
characters. This takes all the existing pairs and adds their counts to the pair(s) they map to
when the mapped character is inserted.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.into_count_by.html" title="advent_of_code_2021::day_14::into_count_by fn">into_count_by</a></div><div class="item-right docblock-short"><p>Reduce the pair mapping into a count of characters. This needs to be called twice once for each
element in the pair, to account for the first and last character that are each only in one pair.
The mapping parameter is to capture this difference, and maps a pair count entry from the
Polymer into the character this invocation cares about</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.into_pair_counts.html" title="advent_of_code_2021::day_14::into_pair_counts fn">into_pair_counts</a></div><div class="item-right docblock-short"><p>Split a list of characters into the counts of all the consecutive pairs that exist. The hard
work is delegated to library functions <a href="https://doc.rust-lang.org/1.57.0/std/primitive.slice.html#method.windows" title="slice::windows"><code>slice::windows</code></a> to give an iterator of the pairs
and <a href="../../itertools/trait.Itertools.html#method.counts" title="Itertools::counts"><code>Itertools::counts</code></a> to reduce that to the required map.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.iterate.html" title="advent_of_code_2021::day_14::iterate fn">iterate</a></div><div class="item-right docblock-short"><p>Recursively apply <a href="fn.intersperse.html" title="intersperse"><code>intersperse</code></a> the required number of times</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.parse_input.html" title="advent_of_code_2021::day_14::parse_input fn">parse_input</a></div><div class="item-right docblock-short"><p>The types required to make today’s solution work are pretty complex, so there is quite a lot of
work here to take a relatively simple input format into the complex format that makes the logic
efficient. A bunch of the tests need to convert intermediate polymer string representations into
the map of pair counts used internally, so this is delegated to <a href="fn.into_pair_counts.html" title="into_pair_counts"><code>into_pair_counts</code></a>.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.polymer_length.html" title="advent_of_code_2021::day_14::polymer_length fn">polymer_length</a></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.run.html" title="advent_of_code_2021::day_14::run fn">run</a></div><div class="item-right docblock-short"><p>The entry point for running the solutions with the ‘real’ puzzle input.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.summarise.html" title="advent_of_code_2021::day_14::summarise fn">summarise</a></div><div class="item-right docblock-short"><p>This is responsible for converting the internal representation of a polymer into the data needed
to provide the puzzle solution. It also returns the intermediary hashmap so that this can be
verified in tests against the example provided in the specification.</p>
</div></div></div><h2 id="types" class="section-header"><a href="#types">Type Definitions</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="type" href="type.PairMap.html" title="advent_of_code_2021::day_14::PairMap type">PairMap</a></div><div class="item-right docblock-short"></div></div><div class="item-row"><div class="item-left module-item"><a class="type" href="type.Polymer.html" title="advent_of_code_2021::day_14::Polymer type">Polymer</a></div><div class="item-right docblock-short"></div></div></div></section><section id="search" class="content hidden"></section><div id="rustdoc-vars" data-root-path="../../" data-current-crate="advent_of_code_2021" data-search-index-js="../../search-index.js" data-search-js="../../search.js"></div>
    <script src="../../main.js"></script>
</body></html>