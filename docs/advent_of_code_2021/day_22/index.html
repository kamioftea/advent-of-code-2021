<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="This is my solution for Advent of Code - Day 22 - Reactor Reboot"><meta name="keywords" content="rust, rustlang, rust-lang, day_22"><title>advent_of_code_2021::day_22 - Rust</title><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../../ayu.css" disabled ><script id="default-settings" ></script><script src="../../storage.js"></script><script src="../../crates.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../favicon.svg"><style type="text/css">#crate-search{background-image:url("../../down-arrow.svg");}</style></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a href='../../advent_of_code_2021/index.html'><div class='logo-container rust-logo'><img src='../../rust-logo.png' alt='logo'></div></a><h2 class="location">Module day_22</h2><div class="sidebar-elems"><div class="block items"><ul><li><a href="#structs">Structs</a></li><li><a href="#functions">Functions</a></li></ul></div><div id="sidebar-vars" data-name="day_22" data-ty="mod" data-relpath="./"></div><script defer src="./sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="18" height="18" alt="Pick another theme!" src="../../brush.svg"></button><div id="theme-choices" role="menu"></div></div><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../../settings.html" title="settings"><img width="18" height="18" alt="Change settings" src="../../wheel.svg"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="in-band">Module <a href="../index.html">advent_of_code_2021</a>::<wbr><a class="mod" href="#">day_22</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../../src/advent_of_code_2021/day_22.rs.html#1-585" title="goto source code">[src]</a></span></h1><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>This is my solution for <a href="https://adventofcode.com/2021/day/22">Advent of Code - Day 22 - <em>Reactor Reboot</em></a></p>
<p>Today was about toggling cubes of cells in a 3d grid. Part one limited this to a cubic volume
101 units³, but the puzzle input and description was very heavily hinting that part two was the
same, but using all the data, making it vastly bigger. The program would take a long time to
flip all the required bits, and likely run out of memory trying to represent each cell, so I was
looking for some form of optimisation. I though about tracking for a cube which sections had
been taken out / added in but that got pretty convoluted to track which cube was responsible for
tracking each bit.</p>
<p>This meant I needed a solution that guaranteed each cell was covered by
exactly one cuboid. So I decided upon when a new cube intersects with existing active (on)
cubes, explode the old cubes into up to 6 pieces, (slice of x on both sides, then y on both
sides, then z on both sides), so that none of them intersect with the new cube or each other.
Then if the new cube is on, also add it to the list of cubes.</p>
<p>This could still get to a very large list of cubes, but in reality most cubes will only cause a
small number to explode. The puzzle input in full mode ends up as ~3.5k cubes. The solution then
becomes bounded by the relatively small number of instructions, and is independent of the
grid-size, which is key to it running small and fast enough.</p>
<p><a href="struct.Cuboid.html" title="Cuboid"><code>Cuboid</code></a> is used to track each cuboid, and <a href="struct.Instruction.html" title="Instruction"><code>Instruction</code></a> wraps a cuboid and whether it flips
its contents to on or off. <a href="struct.Instruction.html#method.from" title="Instruction::from"><code>Instruction::from</code></a> parses a line of input, and <a href="fn.parse_input.html" title="parse_input"><code>parse_input</code></a>
uses this to build the whole instruction list. <a href="fn.volume_active.html" title="volume_active"><code>volume_active</code></a> is the entry point into the
solution for both parts. It folds each instruction into a list of ‘on’ cubes calling
<a href="fn.merge_instruction.html" title="merge_instruction"><code>merge_instruction</code></a> to build each iteration from the previous iteration and the next
instruction. In turn, this uses <a href="struct.Cuboid.html#method.diff_and_split" title="Cuboid::diff_and_split"><code>Cuboid::diff_and_split</code></a> for each existing cube, which returns
a list of cubes to add to the next generation.</p>
<p>For part one, the instruction list is first filtered by <a href="fn.limit_instructions.html" title="limit_instructions"><code>limit_instructions</code></a> to only
the instructions with cuboids (or partial cuboids) that fit in <a href="fn.initialisation_limit.html" title="initialisation_limit"><code>initialisation_limit</code></a>. For
part two, the unaltered instruction set is used. Both <a href="struct.Cuboid.html#method.diff_and_split" title="Cuboid::diff_and_split"><code>Cuboid::diff_and_split</code></a> and
<a href="fn.limit_instructions.html" title="limit_instructions"><code>limit_instructions</code></a> use <a href="struct.Cuboid.html#method.intersect" title="Cuboid::intersect"><code>Cuboid::intersect</code></a> which returns the cuboid region where both
overlap, or <code>None</code> if they are disjoint.</p>
</div></details><h2 id="structs" class="section-header"><a href="#structs">Structs</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Cuboid.html" title="advent_of_code_2021::day_22::Cuboid struct">Cuboid</a></div><div class="item-right docblock-short"><p>Represents a cuboid as its range of co-ordinates on each axis. Both values are inclusive.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Instruction.html" title="advent_of_code_2021::day_22::Instruction struct">Instruction</a></div><div class="item-right docblock-short"><p>Represents a line of input as the <a href="struct.Cuboid.html" title="Cuboid"><code>Cuboid</code></a> region it intersects, and whether it toggles its
contents on or off.</p>
</div></div></div><h2 id="functions" class="section-header"><a href="#functions">Functions</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.initialisation_limit.html" title="advent_of_code_2021::day_22::initialisation_limit fn">initialisation_limit</a></div><div class="item-right docblock-short"><p>The initialisation phase (part_one) is limited to a cube 50 units from the origin on all axes.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.limit_instructions.html" title="advent_of_code_2021::day_22::limit_instructions fn">limit_instructions</a></div><div class="item-right docblock-short"><p>Filter the list of instructions to just the region that intersects the limit <a href="struct.Cuboid.html" title="Cuboid"><code>Cuboid</code></a>. If an
instruction’s cuboid is partially in the area, instead include a modified instruction that just
contains the intersection with the limit.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.merge_instruction.html" title="advent_of_code_2021::day_22::merge_instruction fn">merge_instruction</a></div><div class="item-right docblock-short"><p>Merge an instruction into the current list of cuboids. Use <a href="struct.Cuboid.html#method.diff_and_split" title="Cuboid::diff_and_split"><code>Cuboid::diff_and_split</code></a> to remove
the instruction’s cuboid from other cuboids it overlaps. Then if it is itself on, add the new
cuboid to the list to mark that its entire region is now active.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.parse_input.html" title="advent_of_code_2021::day_22::parse_input fn">parse_input</a></div><div class="item-right docblock-short"><p>Parse the puzzle input as a list of instructions</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.run.html" title="advent_of_code_2021::day_22::run fn">run</a></div><div class="item-right docblock-short"><p>The entry point for running the solutions with the ‘real’ puzzle input.</p>
</div></div><div class="item-row"><div class="item-left module-item"><a class="fn" href="fn.volume_active.html" title="advent_of_code_2021::day_22::volume_active fn">volume_active</a></div><div class="item-right docblock-short"><p>Fold the list of instructions into a list of cuboids that describe the entire active area, then
sum the volumes of those cuboids to get the total active volume.</p>
</div></div></div></section><section id="search" class="content hidden"></section><div id="rustdoc-vars" data-root-path="../../" data-current-crate="advent_of_code_2021" data-search-index-js="../../search-index.js" data-search-js="../../search.js"></div>
    <script src="../../main.js"></script>
</body></html>