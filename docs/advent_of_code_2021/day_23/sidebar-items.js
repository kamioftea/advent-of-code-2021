initSidebarItems({"constant":[["COSTS","The cost to move each type of Amphipod in order A-D"]],"fn":[["build_goal","Return a burrow that represents the target state for a given depth."],["build_states","This handles building the possible next states respecting the limits on Amphipod movement returning a list of the possible states and the cost for each."],["expand_burrow","Add in the two extra lines that were hidden behind the fold for part two."],["find_shortest_path","Use Dijkstra’s algorithm to represent the puzzle as a graph of states, and find the shortest path (i.e. lowest total move energy) for the Amphipods to all reach their desired tunnel."],["parse_input","Parse the ascii-art diagram into the internal representation."],["parse_letter","Turn a letter in the ascii-art into the number we use to represent it internally"],["run","The entry point for running the solutions with the ‘real’ puzzle input."]],"struct":[["Burrow","Represents a burrow as an integer that can be used as a list of 3-bit sections. 0-6 are the 7 cells in the hallway where a Amphipod can stop, the cells adjacent to each side tunnel are not represented here, and instead handled by [`build_states`] accounting for them when calculating costs. The remaining cells represent the side-tunnels, reading like a book. You can walk down a tunnel by staring at indices 7, 8, 9 or 10, and increasing by 4 each step. It is possible to represent a burrow of up to depth 8 in the u128 used."],["State","Wrapper for a Burrow state with the cost to reach that state. Implements [`Ord`] in reverse order so that we can use Rust’s built in max-[`BinaryHeap`] as a min-heap."]]});